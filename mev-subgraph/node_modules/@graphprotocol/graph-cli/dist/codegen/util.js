export function disambiguateNames({ values, getName, setName, }) {
    const collisionCounter = new Map();
    return values.map((value, index) => {
        const name = handleReservedWord(getName(value, index));
        const counter = collisionCounter.get(name);
        if (counter === undefined) {
            collisionCounter.set(name, 1);
            return setName(value, name);
        }
        collisionCounter.set(name, counter + 1);
        return setName(value, `${name}${counter}`);
    });
}
const RESERVED_WORDS = new Set([
    'await',
    'break',
    'case',
    'catch',
    'class',
    'const',
    'continue',
    'debugger',
    'delete',
    'do',
    'else',
    'enum',
    'export',
    'extends',
    'false',
    'finally',
    'function',
    'if',
    'implements',
    'import',
    'in',
    'interface',
    'let',
    'new',
    'package',
    'private',
    'protected',
    'public',
    'return',
    'super',
    'switch',
    'static',
    'this',
    'throw',
    'true',
    'try',
    'typeof',
    'var',
    'while',
    'with',
    'yield',
]);
export function handleReservedWord(name) {
    return RESERVED_WORDS.has(name) ? `${name}_` : name;
}
export function isTupleType(t) {
    return t === 'tuple';
}
export function containsTupleType(t) {
    return isTupleType(t) || isTupleArrayType(t) || isTupleMatrixType(t);
}
export function isTupleArrayType(t) {
    return t.match(/^tuple\[([0-9]+)?\]$/);
}
export function isTupleMatrixType(t) {
    return t.match(/^tuple\[([0-9]+)?\]\[([0-9]+)?\]$/);
}
export const unrollTuple = ({ path, value, }) => value.components.reduce((acc, component, index) => {
    const name = component.name || `value${index}`;
    return acc.concat(component.type === 'tuple'
        ? unrollTuple({ path: [...path, name], index, value: component })
        : [{ path: [...path, name], type: component.type }]);
}, []);
