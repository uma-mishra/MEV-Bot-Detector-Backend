// mev-subgraph/src/mapping.ts (AssemblyScript Mapping Handlers)

// Import necessary types and functions from The Graph's AssemblyScript API.
import { BigInt, Bytes, log } from "@graphprotocol/graph-ts";
// Import the `Swap` event type from the generated ABI bindings.
// This path `../generated/UniswapV2Router02/IUniswapV2Router02` is generated by `graph codegen`.
import { Swap as SwapEvent } from "../generated/UniswapV2Router02/IUniswapV2Router02";
// Import our custom `MevAttack` entity definition from the generated schema bindings.
import { MevAttack } from "../generated/schema";

// This is a highly simplified mapping handler.
// Real MEV detection in a subgraph is extremely complex and often involves:
// 1. Indexing all relevant transactions within a block.
// 2. Analyzing transaction traces (if supported by the subgraph's indexing service).
// 3. Reconstructing the state changes to identify frontruns/backruns.
// 4. Identifying specific contract interactions (e.g., Uniswap swaps).

// For the purpose of this problem statement, we'll demonstrate how to save
// a hypothetical MEV attack based on a `Swap` event.
// In a real scenario, `handleSwap` would be much more sophisticated,
// likely querying other entities (e.g., `Transaction` entities that you'd
// create by indexing all block transactions) to find the frontrun/backrun.

// `export function handleSwap(event: SwapEvent): void`
// This function is called by The Graph Node whenever a `Swap` event is
// emitted by the `UniswapV2Router02` contract (as configured in `subgraph.yaml`).
// NOTE: As mentioned in `subgraph.yaml`, the Uniswap V2 Router itself
// does not emit `Swap` events; these are emitted by Uniswap V2 Pair contracts.
// This handler serves as a conceptual example of how you would process an event
// and create an `MevAttack` entity.
export function handleSwap(event: SwapEvent): void {
  // Log information about the event being processed. This is useful for debugging.
  log.info("Processing Swap event for transaction: {}", [event.transaction.hash.toHexString()]);

  // Create a new `MevAttack` entity.
  // The `id` must be unique. We use the transaction hash of the event as the ID.
  let mevAttack = new MevAttack(event.transaction.hash.toHexString());

  // Populate the fields of the `MevAttack` entity using data from the event and transaction context.
  // These values are placeholders for a real MEV detection logic within a subgraph.
  mevAttack.victim = event.transaction.from; // The sender of the transaction that emitted the swap event
  mevAttack.attacker = Bytes.fromHexString("0x000000000000000000000000000000000000dead"); // Placeholder for attacker address
  mevAttack.profitEth = BigInt.fromI32(0).toBigDecimal(); // Placeholder for profit (in ETH)
  mevAttack.timestamp = event.block.timestamp; // Timestamp of the block the event occurred in
  mevAttack.blockNumber = event.block.number; // Block number the event occurred in
  mevAttack.transactionHash = event.transaction.hash; // Hash of the transaction that emitted the event

  // Placeholder for frontrun/backrun transaction hashes.
  // In a real scenario, you'd find these by analyzing other transactions in the same block
  // or by tracing the transaction.
  mevAttack.frontrunTxHash = Bytes.fromHexString("0x0000000000000000000000000000000000000001");
  mevAttack.backrunTxHash = Bytes.fromHexString("0x0000000000000000000000000000000000000002");

  // Placeholder for token details and amounts.
  // In a real scenario, these would be extracted from the `SwapEvent` parameters
  // or decoded from the transaction's input data.
  mevAttack.tokenIn = Bytes.fromHexString("0x0000000000000000000000000000000000000003");
  mevAttack.tokenOut = Bytes.fromHexString("0x0000000000000000000000000000000000000004");
  mevAttack.amountIn = BigInt.fromI32(1000000000); // Example: 1 token with 9 decimal places
  mevAttack.amountOutMin = BigInt.fromI32(950000000); // Example: 0.95 token out min
  mevAttack.actualAmountOut = BigInt.fromI32(980000000); // Example: 0.98 token actual out
  mevAttack.gasPremium = BigInt.fromI32(10000000000); // Example: 10 Gwei gas premium

  mevAttack.save();
}